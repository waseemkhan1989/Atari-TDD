<?xml version="1.0"?>
<doc>
    <assembly>
        <name>JetBrains.RdFramework</name>
    </assembly>
    <members>
        <member name="T:JetBrains.Rd.Base.IPerContextMap`2">
             <summary>
             <para>
             A collection that automatically maps values to keys from RdContext's value set.
             Key-value pairs in this map are automatically managed based on possible values of RdContext.
             </para>
            
             <para>
             As context value sets are protocol-specific, this map will behave differently depending on whether or not it's bound to a <see cref="T:JetBrains.Rd.IProtocol"/>.
             An unbound map will automatically create mappings for all context values it's accessed with. When a map is bound later, all values not present in protocol value set will be silently dropped.
             </para>
             </summary>
             <seealso cref="M:JetBrains.Rd.Impl.ProtocolContexts.GetValueSet``1(JetBrains.Rd.RdContext{``0})"/>
        </member>
        <member name="P:JetBrains.Rd.Base.IPerContextMap`2.Context">
            <summary>
            The context that is used by this map. Must be heavy.
            </summary>
        </member>
        <member name="M:JetBrains.Rd.Base.IPerContextMap`2.GetForCurrentContext">
            <summary>
            Gets the value associated with current context value, equivalent to this[Key.Value].
            If the context doesn't have a value set, or key's protocol value set does not contain the current context value, this will throw an exception
            </summary>
        </member>
        <member name="P:JetBrains.Rd.Base.IPerContextMap`2.Item(`0)">
            <summary>
            Gets the value associated with specified context value, or throws an exception if none is associated.
            When this map is not bound, this will automatically create a new mapping instead of throwing
            </summary>
        </member>
        <member name="M:JetBrains.Rd.Base.IPerContextMap`2.TryGetValue(`0,`1@)">
            <summary>
            Gets the value associated with specified context value and returns true, or returns false if none is associated
            When this map is not bound, this will automatically create a new mapping instead of returning false
            </summary>
        </member>
        <member name="T:JetBrains.Rd.IInternRoot`1">
            <summary>
            Interns values sent over protocol
            </summary>
        </member>
        <member name="M:JetBrains.Rd.IInternRoot`1.TryGetInterned(`0)">
            <summary>
            Tries to get an ID for a value. Doesn't intern it if it's not interned.
            </summary>
        </member>
        <member name="M:JetBrains.Rd.IInternRoot`1.Intern(`0)">
            <summary>
            Interns a value and returns an ID for it. May return invalid ID in case of multithreaded contention.
            </summary>
        </member>
        <member name="M:JetBrains.Rd.IInternRoot`1.UnIntern``1(JetBrains.Rd.InternId)">
            <summary>
            Gets a value from an interned ID. Throws an exception if the ID doesn't correspond to a value
            </summary>
        </member>
        <member name="M:JetBrains.Rd.IInternRoot`1.TryUnIntern``1(JetBrains.Rd.InternId,``0@)">
            <summary>
            Gets a value from an interned ID. Returns true if successful, false otherwise
            </summary>
        </member>
        <member name="M:JetBrains.Rd.IInternRoot`1.Remove(`0)">
            <summary>
            Removes an interned value. Any future attempts to un-intern IDs previously associated with this value will fail.
            Not thread-safe. It's up to user to ensure that the value being removed is not being used in messages written on background threads.
            </summary>
        </member>
        <member name="T:JetBrains.Rd.InternId">
            <summary>
            An ID representing an interned value
            </summary>
        </member>
        <member name="P:JetBrains.Rd.InternId.IsValid">
            <summary>
            True if this ID represents an actual interned value. False indicates a failed interning operation or unset value
            </summary>
        </member>
        <member name="P:JetBrains.Rd.InternId.IsLocal">
            <summary>
            True if this ID represents a value interned by local InternRoot 
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.Protocol.ProtocolInternRootRdId">
            <summary>
            Should match textual RdId of protocol intern root in Kotlin/js/cpp counterpart
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.Protocol.ProtocolInternScopeStringId">
            <summary>
            Should match whatever is in rd-gen for ProtocolInternScope
            </summary>
        </member>
        <member name="T:JetBrains.Rd.Impl.ProtocolContexts">
            <summary>
            This class handles RdContext on protocol level. It tracks existing contexts and allows access to their value sets (when present)
            </summary>
        </member>
        <member name="M:JetBrains.Rd.Impl.ProtocolContexts.GetValueSet``1(JetBrains.Rd.RdContext{``0})">
            <summary>
            Get a value set for a given key. The values are local relative to transform
            </summary>
        </member>
        <member name="M:JetBrains.Rd.Impl.ProtocolContexts.RegisterContext``1(JetBrains.Rd.RdContext{``0})">
            <summary>
            Registers a context to be used with this context handler. Must be invoked on protocol's scheduler
            </summary>
        </member>
        <member name="M:JetBrains.Rd.Impl.ProtocolContexts.ReadContextsIntoCookie(JetBrains.Serialization.UnsafeReader)">
            <summary>
            Reads context values from a message, sets current context to them, and returns a cookie to restore previous context
            </summary>
        </member>
        <member name="M:JetBrains.Rd.Impl.ProtocolContexts.WriteContexts(JetBrains.Serialization.UnsafeWriter)">
            <summary>
            Writes the current context values
            </summary>
        </member>
        <member name="M:JetBrains.Rd.Impl.ProtocolContexts.WriteEmptyContexts(JetBrains.Serialization.UnsafeWriter)">
            <summary>
            Writes an empty context
            </summary>
        </member>
        <member name="T:JetBrains.Rd.Impl.RdSecureString">
            <summary>
            This is a temporary stub for proper secure strings in protocol
            Unlike a normal string, this one won't be stored in logs or any other string representations of protocol entities
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.SocketWire.Base.TimeoutMs">
            <summary>
            Timeout for <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)"/>  and for <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)"/>  from socket (to guarantee read_thread termination if <see cref="M:System.Net.Sockets.Socket.Close"/> doesn't
            lead to exception thrown by <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)"/> 
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.SocketWire.Base.Id">
            <summary>
            For logging
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.SocketWire.Base.myLifetime">
            <summary>
            Lifetime of this wire. If counterpart disconnects, lifetime is not terminate automatically.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.SocketWire.Base.myCurrentTimeStamp">
            <summary>
            Timestamp of this wire which increases at intervals of <see cref="P:JetBrains.Rd.Impl.SocketWire.Base.HeartBeatInterval"/>
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.SocketWire.Base.myCounterpartTimestamp">
            <summary>
            Actual notion about counterpart's <see cref="F:JetBrains.Rd.Impl.SocketWire.Base.myCurrentTimeStamp"/>
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.SocketWire.Base.myCounterpartNotionTimestamp">
            <summary>
            The latest received counterpart's notion of this wire's <see cref="F:JetBrains.Rd.Impl.SocketWire.Base.myCurrentTimeStamp"/>
            </summary>
        </member>
        <member name="T:JetBrains.Rd.Impl.WebSocketSharp.ByteOrder">
            <summary>
            Specifies the byte order.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.ByteOrder.Little">
            <summary>
            Specifies Little-endian.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.ByteOrder.Big">
            <summary>
            Specifies Big-endian.
            </summary>
        </member>
        <member name="T:JetBrains.Rd.Impl.WebSocketSharp.CloseStatusCode">
            <summary>
            Indicates the status code for the WebSocket connection close.
            </summary>
            <remarks>
              <para>
              The values of this enumeration are defined in
              <see href="http://tools.ietf.org/html/rfc6455#section-7.4">
              Section 7.4</see> of RFC 6455.
              </para>
              <para>
              "Reserved value" cannot be sent as a status code in
              closing handshake by an endpoint.
              </para>
            </remarks>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.CloseStatusCode.Normal">
            <summary>
            Equivalent to close status 1000. Indicates normal close.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.CloseStatusCode.Away">
            <summary>
            Equivalent to close status 1001. Indicates that an endpoint is
            going away.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.CloseStatusCode.ProtocolError">
            <summary>
            Equivalent to close status 1002. Indicates that an endpoint is
            terminating the connection due to a protocol error.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.CloseStatusCode.UnsupportedData">
            <summary>
            Equivalent to close status 1003. Indicates that an endpoint is
            terminating the connection because it has received a type of
            data that it cannot accept.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.CloseStatusCode.Undefined">
            <summary>
            Equivalent to close status 1004. Still undefined. A Reserved value.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.CloseStatusCode.NoStatus">
            <summary>
            Equivalent to close status 1005. Indicates that no status code was
            actually present. A Reserved value.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.CloseStatusCode.Abnormal">
            <summary>
            Equivalent to close status 1006. Indicates that the connection was
            closed abnormally. A Reserved value.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.CloseStatusCode.InvalidData">
            <summary>
            Equivalent to close status 1007. Indicates that an endpoint is
            terminating the connection because it has received a message that
            contains data that is not consistent with the type of the message.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.CloseStatusCode.PolicyViolation">
            <summary>
            Equivalent to close status 1008. Indicates that an endpoint is
            terminating the connection because it has received a message that
            violates its policy.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.CloseStatusCode.TooBig">
            <summary>
            Equivalent to close status 1009. Indicates that an endpoint is
            terminating the connection because it has received a message that
            is too big to process.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.CloseStatusCode.MandatoryExtension">
            <summary>
            Equivalent to close status 1010. Indicates that a client is
            terminating the connection because it has expected the server to
            negotiate one or more extension, but the server did not return
            them in the handshake response.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.CloseStatusCode.ServerError">
            <summary>
            Equivalent to close status 1011. Indicates that a server is
            terminating the connection because it has encountered an unexpected
            condition that prevented it from fulfilling the request.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.CloseStatusCode.TlsHandshakeFailure">
            <summary>
            Equivalent to close status 1015. Indicates that the connection was
            closed due to a failure to perform a TLS handshake. A Reserved value.
            </summary>
        </member>
        <member name="M:JetBrains.Rd.Impl.WebSocketSharp.Ext.EqualsWith(System.Int32,System.Char,System.Action{System.Int32})">
            <summary>
            Determines whether the specified <see cref="T:System.Int32"/> equals the specified <see cref="T:System.Char"/>,
            and invokes the specified <c>Action&lt;int&gt;</c> delegate at the same time.
            </summary>
            <returns>
            <c>true</c> if <paramref name="value"/> equals <paramref name="c"/>;
            otherwise, <c>false</c>.
            </returns>
            <param name="value">
            An <see cref="T:System.Int32"/> to compare.
            </param>
            <param name="c">
            A <see cref="T:System.Char"/> to compare.
            </param>
            <param name="action">
            An <c>Action&lt;int&gt;</c> delegate that references the method(s) called
            at the same time as comparing. An <see cref="T:System.Int32"/> parameter to pass to
            the method(s) is <paramref name="value"/>.
            </param>
        </member>
        <member name="T:JetBrains.Rd.Impl.WebSocketSharp.Fin">
            <summary>
            Indicates whether a WebSocket frame is the final frame of a message.
            </summary>
            <remarks>
            The values of this enumeration are defined in
            <see href="http://tools.ietf.org/html/rfc6455#section-5.2">Section 5.2</see> of RFC 6455.
            </remarks>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.Fin.More">
            <summary>
            Equivalent to numeric value 0. Indicates more frames of a message follow.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.Fin.Final">
            <summary>
            Equivalent to numeric value 1. Indicates the final frame of a message.
            </summary>
        </member>
        <member name="T:JetBrains.Rd.Impl.WebSocketSharp.HttpVersion">
            <summary>
            Provides the HTTP version numbers.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.HttpVersion.Version10">
            <summary>
            Provides a <see cref="T:System.Version"/> instance for the HTTP/1.0.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.HttpVersion.Version11">
            <summary>
            Provides a <see cref="T:System.Version"/> instance for the HTTP/1.1.
            </summary>
        </member>
        <member name="T:JetBrains.Rd.Impl.WebSocketSharp.Mask">
            <summary>
            Indicates whether the payload data of a WebSocket frame is masked.
            </summary>
            <remarks>
            The values of this enumeration are defined in
            <see href="http://tools.ietf.org/html/rfc6455#section-5.2">Section 5.2</see> of RFC 6455.
            </remarks>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.Mask.Off">
            <summary>
            Equivalent to numeric value 0. Indicates not masked.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.Mask.On">
            <summary>
            Equivalent to numeric value 1. Indicates masked.
            </summary>
        </member>
        <member name="T:JetBrains.Rd.Impl.WebSocketSharp.Opcode">
            <summary>
            Indicates the WebSocket frame type.
            </summary>
            <remarks>
            The values of this enumeration are defined in
            <see href="http://tools.ietf.org/html/rfc6455#section-5.2">
            Section 5.2</see> of RFC 6455.
            </remarks>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.Opcode.Cont">
            <summary>
            Equivalent to numeric value 0. Indicates continuation frame.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.Opcode.Text">
            <summary>
            Equivalent to numeric value 1. Indicates text frame.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.Opcode.Binary">
            <summary>
            Equivalent to numeric value 2. Indicates binary frame.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.Opcode.Close">
            <summary>
            Equivalent to numeric value 8. Indicates connection close frame.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.Opcode.Ping">
            <summary>
            Equivalent to numeric value 9. Indicates ping frame.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.Opcode.Pong">
            <summary>
            Equivalent to numeric value 10. Indicates pong frame.
            </summary>
        </member>
        <member name="T:JetBrains.Rd.Impl.WebSocketSharp.Rsv">
            <summary>
            Indicates whether each RSV (RSV1, RSV2, and RSV3) of a WebSocket frame is non-zero.
            </summary>
            <remarks>
            The values of this enumeration are defined in
            <see href="http://tools.ietf.org/html/rfc6455#section-5.2">Section 5.2</see> of RFC 6455.
            </remarks>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.Rsv.Off">
            <summary>
            Equivalent to numeric value 0. Indicates zero.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.Rsv.On">
            <summary>
            Equivalent to numeric value 1. Indicates non-zero.
            </summary>
        </member>
        <member name="T:JetBrains.Rd.Impl.WebSocketSharp.WebSocketException">
            <summary>
            The exception that is thrown when a fatal error occurs in
            the WebSocket communication.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.WebSocketFrameHeader.PayloadMaxLength">
            <summary>
            Represents the allowable max length.
            </summary>
            <remarks>
              <para>
              A <see cref="T:JetBrains.Rd.Impl.WebSocketSharp.WebSocketException"/> will occur if the payload data length is
              greater than the value of this field.
              </para>
              <para>
              If you would like to change the value, you must set it to a value between
              <c>WebSocket.FragmentLength</c> and <c>Int64.MaxValue</c> inclusive.
              </para>
            </remarks>
        </member>
        <member name="M:JetBrains.Rd.ITypesRegistrar.TryRegister(JetBrains.Rd.RdId,JetBrains.Rd.ISerializers)">
            <summary>
            Tries to discovery type with specific <see cref="T:JetBrains.Rd.RdId"/>.
            If it succeeds then should Invoke <see cref="!:ISerializers.Register&lt;T&gt;"/> method on provided serializers.
            </summary>
            <param name="id"></param>
            <param name="serializers"></param>
        </member>
        <member name="M:JetBrains.Rd.WireBase.SendPkg(JetBrains.Serialization.UnsafeWriter.Cookie)">
            <summary>
            Actual send package: len(4 bytes) + id (8 bytes) + payload
            </summary>
            <param name="pkg">Package to transmit</param>
        </member>
        <member name="T:JetBrains.Rd.RdContext`1">
            <summary>
            Describes a context and provides access to value associated with this context.
            The associated value is thread-local and synchronized between send/advise pairs on <see cref="T:JetBrains.Rd.IWire"/>. The associated value will be the same in handler method in <see cref="M:JetBrains.Rd.IWire.Advise(JetBrains.Lifetimes.Lifetime,JetBrains.Rd.Base.IRdWireable)"/> as it was in <see cref="M:JetBrains.Rd.IWire.Send``1(JetBrains.Rd.RdId,``0,System.Action{``0,JetBrains.Serialization.UnsafeWriter})"/>.
            Instances of this class with the same <see cref="!:RdContext.Key"/> will share the associated value.
            Best practice is to declare contexts in toplevel entities in protocol model using <c>Toplevel.context</c>. Manual declaration is also possible.
            </summary>
            <typeparam name="T">The type of value stored by this context</typeparam>
        </member>
        <member name="M:JetBrains.Rd.RdContext`1.#ctor(System.String,System.Boolean,JetBrains.Rd.CtxReadDelegate{`0},JetBrains.Rd.CtxWriteDelegate{`0})">
            <summary>
            
            </summary>
            <param name="key">Textual name of this context. This is used to match this with protocol counterparts</param>
            <param name="isHeavy">Whether or not this context is heavy. A heavy context maintains a value set and interns values. A light context sends values as-is and does not maintain a value set.</param>
            <param name="readDelegate">Serializer to be used with this context.</param>
            <param name="writeDelegate">Serializer to be used with this context.</param>
        </member>
        <member name="P:JetBrains.Rd.RdContext`1.Value">
            <summary>
            Current (thread- or async-local) value for this context
            </summary>
        </member>
        <member name="M:JetBrains.Rd.RdContext`1.PushContext(`0)">
            <summary>
            Pushes current context value to a thread-local stack and sets new value
            </summary>
        </member>
        <member name="M:JetBrains.Rd.RdContext`1.PopContext">
            <summary>
            Restores previous context value from a thread-local stack
            </summary>
        </member>
        <member name="M:JetBrains.Rd.RdId.DefineByFqn(System.Type)">
            <summary>
            Define an RdId by fully-qualified type name.
            You should use it only in case of C#-C# communication.
            </summary>
        </member>
        <member name="T:JetBrains.Rd.Reflection.CollectionSerializers">
            <summary>
            Special asymmetric serializers for collections. Used in reflection serializers to use covariant conversion instead of runtime casting.
            </summary>
        </member>
        <member name="M:JetBrains.Rd.Reflection.ProxyGenerator.CreateAdapter(System.Type,System.Reflection.MethodInfo)">
             <summary>
             Wrap method into Tuple-like adapter for using regular .NEt method as RdCall endpoint.
            
             Expected signature for sync methods
               (this, Lifetime, TReq) → RdTask{TRes}
             async methods:
               (this, Lifetime, TReq) → Task{TRes}
             </summary>
             <returns></returns>
        </member>
        <member name="M:JetBrains.Rd.Reflection.ProxyGenerator.GetRequstType(System.Reflection.MethodInfo)">
             <summary>
             Get the list of tuples, used to
            
             Note the special treatment of Lifetime and CancellationToken types - they are not included in the result.
             </summary>
             <param name="method"></param>
             <returns></returns>
        </member>
        <member name="M:JetBrains.Rd.Reflection.ProxyGenerator.LoadArgument(System.Reflection.Emit.ILGenerator,System.Int32)">
            <summary>
            Loads the given argument on the stack
            </summary>
        </member>
        <member name="T:JetBrains.Rd.Reflection.ProxyGeneratorUtil">
            <summary>
            Helpers method which used by generated proxies.
            </summary>
        </member>
        <member name="M:JetBrains.Rd.Reflection.RdExtReflectionBindableBase.OnActivated">
            <summary>
            Override this method to set-up data flow in your RdExt
            </summary>
        </member>
        <member name="M:JetBrains.Rd.Reflection.RdReflectionBindableBase.OnActivated">
            <summary>
            Override this method to set-up data flow in your RdExt
            </summary>
        </member>
        <member name="T:JetBrains.Rd.Reflection.ReflectionRdActivator">
             <summary>
             To get maximal performance of  Rd framework you should directly provide serializers to every Model and Property.
            
             Creating models by hand with this approach is tedious and error-prone.  The main idea behind <see
             cref="T:JetBrains.Rd.Reflection.ReflectionRdActivator" /> is to automatically create RdExt and initialize fields and properties with
             appropriate serializers.
             
             </summary>
        </member>
        <member name="M:JetBrains.Rd.Reflection.ReflectionRdActivator.ActivateBind``1(JetBrains.Lifetimes.Lifetime,JetBrains.Rd.IProtocol)">
            <summary>
            Create and bind class with <see cref="T:JetBrains.Rd.Reflection.RdExtAttribute"/>
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Rd.Reflection.ReflectionRdActivator.ActivateBind(System.Type,JetBrains.Lifetimes.Lifetime,JetBrains.Rd.IProtocol)">
            <summary>
            Create and bind class with <see cref="T:JetBrains.Rd.Reflection.RdExtAttribute"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Rd.Reflection.ReflectionRdActivator.Activate``1">
             <summary>
             Create and initialize RdModel root and its members (including nested RdModels)
            
             It doesn't bind model to Protocol. You may want to use <see cref="M:JetBrains.Rd.Reflection.ReflectionRdActivator.ActivateBind``1(JetBrains.Lifetimes.Lifetime,JetBrains.Rd.IProtocol)"/>
             </summary>
        </member>
        <member name="M:JetBrains.Rd.Reflection.ReflectionRdActivator.Activate(System.Type)">
            <summary>
            Activate <see cref="T:JetBrains.Rd.Reflection.RdExtAttribute"/> and its members.
            Can't be used for data models
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Rd.Reflection.ReflectionRdActivator.SetHandlerTask``2(JetBrains.Rd.Tasks.RdCall{``0,``1},System.Func{JetBrains.Lifetimes.Lifetime,``0,System.Threading.Tasks.Task{``1}})">
            <summary>
             Wrapper method to simplify search with overload resolution for two methods in RdEndpoint
            </summary>
        </member>
        <member name="M:JetBrains.Rd.Reflection.ReflectionRdActivator.SetHandlerTaskVoid``1(JetBrains.Rd.Tasks.RdCall{``0,JetBrains.Core.Unit},System.Func{JetBrains.Lifetimes.Lifetime,``0,System.Threading.Tasks.Task})">
            <summary>
             Wrapper method to simplify search with overload resolution for two methods in RdEndpoint
            </summary>
        </member>
        <member name="M:JetBrains.Rd.Reflection.ReflectionRdActivator.SetHandler``2(JetBrains.Rd.Tasks.RdCall{``0,``1},System.Func{JetBrains.Lifetimes.Lifetime,``0,JetBrains.Rd.Tasks.RdTask{``1}})">
            <summary>
             Wrapper method to simplify search with overload resolution for two methods in RdEndpoint
            </summary>
        </member>
        <member name="M:JetBrains.Rd.Reflection.RdExtAttribute.#ctor(System.Type)">
            <summary>
            Mark RdExt as implementing contract from specific RdRpc interface. That means that this RdExt will be exposed by
            interface name, not by the type itself. It may be used when explicit marking of RdRpc is undesirable.
            </summary>
            <param name="rdRpcInterface">
              RdRpc interface type. Must be implemented by type, which marked by this RdExt attribute.
            </param>
        </member>
        <member name="T:JetBrains.Rd.Reflection.RdRpcAttribute">
            <summary>
            Mark implementing interface of RdExt by this attribute to indicate intent to use this interface for proxy generation
            </summary>
        </member>
        <member name="T:JetBrains.Rd.Reflection.RdScalarAttribute">
            <summary>
            It has no special semantic. Used only to tell ReSharper about ImplicitUse.
            </summary>
        </member>
        <member name="M:JetBrains.Rd.Reflection.RdScalarAttribute.#ctor(System.Type)">
            <summary>
            Provides external marshaller for this type
            </summary>
            <param name="marshaller">
            A type which implements <see cref="T:JetBrains.Rd.Reflection.IIntrinsicMarshaller`1"/> for this type or any base interface.
            Keep in mind that if you provide an serializer for base interface a runtime casting error is possible on the
            receiver side if receiver want to have an inheritor from this interface
            </param>
        </member>
        <member name="T:JetBrains.Rd.Reflection.IProxyTypeMarker">
            <summary>
            Marker interface for proxy types.
            Used to distinguish between proxy-implemented methods, for which we should only initialize RdCall fields and other reactive properties
            and real methods in types, for which we should Bind appropriate RdEndpoint.
            </summary>
        </member>
        <member name="T:JetBrains.Rd.Reflection.ReflectionSerializersFactory">
            <summary>
            Creates and provides access to Reflection-generated serializers for Rd, thread safe
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Reflection.ReflectionSerializersFactory.mySerializers">
            <summary>
            Collection true type to non-polymorphic serializer
            </summary>
        </member>
        <member name="M:JetBrains.Rd.Reflection.ReflectionSerializersFactory.RegisterModelSerializer``1">
            <summary>
            Register serializers for either <see cref="T:JetBrains.Rd.Reflection.RdExtAttribute"/> or <see cref="T:JetBrains.Rd.Reflection.RdModelAttribute"/>
            </summary>
        </member>
        <member name="M:JetBrains.Rd.Reflection.SerializerPair.CreateFromNonProtocolMethods(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
            <summary>
            Create serializer from Read  and Write method without <see cref="T:JetBrains.Rd.SerializationCtx"/>
            </summary>
        </member>
        <member name="M:JetBrains.Rd.Reflection.IScalarSerializers.GetOrCreate(System.Type)">
            <summary>
            Return static serializers for type Static serializer is the serializer which always return provided type and
            never any of the inheritors. It makes sense to ask these serializers for struct, enums and sealed classes
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Rd.Reflection.IScalarSerializers.GetInstanceSerializer(System.Type)">
            <summary>
            Return instance serializers for the type.
            Instance means that Polymorphic types is possible, you can ask here for serializer for interface, for example
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Rd.Reflection.IScalarSerializers.RegisterPolymorphicSerializer(System.Type,JetBrains.Rd.Reflection.SerializerPair)">
            <summary>
            Register custom serializer for provided polymorphic type. It will be used instead of default <see
            cref="T:JetBrains.Rd.Impl.Polymorphic`1"/>. Be aware, that you can register your custom serializer only before any serializer was
            asked via <see cref="M:JetBrains.Rd.Reflection.IScalarSerializers.GetInstanceSerializer(System.Type)"/>.
            </summary>
            <param name="type"></param>
            <param name="serializers"></param>
        </member>
        <member name="T:JetBrains.Rd.Reflection.ReflectionSerializerVerifier">
                <summary>
                Struct, Aggregate, ImmutableList are not supported.
            
                This enbf-like scheme can only be used to understand basic concepts and terms, there is no
                any strong semantics behind several leaf rules.
                <code>
                 //  RdBasic, may have inexact mapping to C# types.
                 IType ::= IBindable | IScalar
                 Bindable ::= NullableBindable | Array[Bindable] | ImmutableListBindable | Class
            
                 IScalar           ::= NullableScalar | NonNullableScalar
                 NullableScalar    ::= Maybe[NonNullableScalar]
                 NonNullableScalar ::= List[IScalar] | Array[IScalar] | PredefinedType | Struct
            
                 NonNullableBindable ::= Array[Bindable] | IReadOnlyList[Bindable] | Class
                 NonNullable::= NonNullableScalar | NonNullableBindable
            
                 FieldType ::=  IScalar|IType|Aggregate
            
                 RdProperty ::= RdProperty[FieldType]
                 RdSet      ::= RdSet[INonNullableScalar]
                 RdMap      ::= RdMap[INonNullableScalar, INonNullable]
                 RdCall     ::= RdCall[IScalar, IScalar]
                 RdSignal   ::= RdSignal[IScalar]
            
                 // C# declarations, [ and ] mean &lt; &gt;.
                 FieldDeclaration[T] ::= C#(public readonly? T identifier)
                 PropertyDeclaration[T] ::= C#(public T identifier { get; })                   |
            																C#(public T identifier { get; private set; })
            																// etc.
            																//
                 PropOrFieldDeclaration[T] ::= FieldDeclaration[T] || PropertyDeclaration[T]
                 EnumDeclaration ::= C#(Enum[enum_const*])
                 // Not supported. No RdGenerator analogue.
                 // StructDeclaration ::= C#(struct field* )
            
                 Member ::= RdSignal | RdProperty| RdList | RdSet | RdMap | RdModel | RdCall
                 Declaration ::= BindableDeclaration | Struct | Enum | RdExtDeclaration
                 BindableDeclaration ::= TopLevel | Class
            
                 MemberDeclaration ::= PropOrFieldDeclaration[Member]
                 RdModelMemberDeclaration ::= PropOrFieldDeclaration[Member|FieldType]
            
                 RdModelDeclaration ::= C#([RdModel] class {RdModelMemberDeclaration*}) | EnumDeclaration | ValueTuple[FieldType{1,7}]
                 RdExtDeclaration ::= C#([RdExt] class {MemberDeclaration}* )
            
                 ROOT ::= RdModelDeclaration ROOT | RdExtDeclaration ROOT | Nothing
                </code>
                </summary>
              *
        </member>
        <member name="F:JetBrains.Rd.Reflection.ScalarSerializer.myTypesCatalog">
            <summary>
            Types catalog required for providing information about statically discovered types during concrete serializer
            construction for sake of possibility for Rd serializers to lookup real type by representing RdId
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Reflection.ScalarSerializer.myStaticSerializers">
            <summary>
            Collection static serializers (polymorphic is not possible here! Only instance serializer can be polymorphic)
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Reflection.ScalarSerializer.myPolySerializers">
            <summary>
            Collection of specific polymorphic serializers. These serializers should be register before activating any Rd
            entity to guarantee consistency of serializers in Rd objects
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Reflection.ScalarSerializer.myPolySerializersSealed">
            <summary>
            A flag to enforce consistency of serializers. New specific poly serializer can't be registered after first query
            of polymorphic serializer from outer world.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Reflection.ScalarSerializer.myBlackListChecker">
             <summary>
             Black listed type. Any attempt to create serializer for these types should throw exception.
             Used to prevent attempts to pass an object which is well-known as non-serializable.
             For example, any component of tree-like structure or object graph should not be passed to
             serializer
            
             This predicate should return true only for blacklisted type
             </summary>
        </member>
        <member name="M:JetBrains.Rd.Reflection.ScalarSerializer.GetOrCreate(System.Type)">
            <summary>
            Return static serializers for type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Rd.Reflection.ScalarSerializer.CreateValueTupleSerializer``1">
            <summary>
            Register serializer for ValueTuples
            </summary>
        </member>
        <member name="M:JetBrains.Rd.Reflection.SerializerReflectionUtil.GetBindableMembers(System.Reflection.TypeInfo)">
            <summary>
            Get lists of members which take part in object serialization.
            Can be used for RdExt, RdModel and any RdScalar.
            </summary>
        </member>
        <member name="T:JetBrains.Rd.Tasks.InprocRpc`2">
            <summary>
            Fake IRdCall implementation for use in single process.
            </summary>
        </member>
        <member name="T:JetBrains.Rd.Tasks.RpcTimeouts">
            <summary>
            Timeouts for synchronous request by <see cref="M:JetBrains.Rd.Tasks.RdCall`2.Sync(`0,JetBrains.Rd.Tasks.RpcTimeouts)"/>. 
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Tasks.RpcTimeouts.Default">
            <summary>
            This timeout is used by <see cref="M:JetBrains.Rd.Tasks.RdCall`2.Sync(`0,JetBrains.Rd.Tasks.RpcTimeouts)"/> if no timeouts specified and <see cref="F:JetBrains.Rd.Tasks.RpcTimeouts.RespectRpcTimeouts"/> is <c>true</c>.
            If request lasts more than 200 ms from UI Thread it could lead to UI freeze, so <see cref="!:ILog.Warn"/> will be reported after <c>Sync</c> finished.
            If request lasts more than 3000 ms it's considered as hang. <c>Sync</c> request interrupts and <see cref="!:ILog.Error"/> is reported.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Tasks.RpcTimeouts.Maximal">
            <summary>
            This timeout is used by <see cref="M:JetBrains.Rd.Tasks.RdCall`2.Sync(`0,JetBrains.Rd.Tasks.RpcTimeouts)"/> if no timeouts specified and <see cref="F:JetBrains.Rd.Tasks.RpcTimeouts.RespectRpcTimeouts"/> is <c>false</c>.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Tasks.RpcTimeouts.RespectRpcTimeouts">
            <summary>
            Static property used mainly for tests. <c>true</c> by default. If <c>false</c> <see cref="F:JetBrains.Rd.Tasks.RpcTimeouts.Maximal"/> timeouts are used by
            <see cref="M:JetBrains.Rd.Tasks.RdCall`2.Sync(`0,JetBrains.Rd.Tasks.RpcTimeouts)"/> by default.
            </summary>
        </member>
        <member name="M:JetBrains.Rd.Tasks.RpcTimeouts.Max(JetBrains.Rd.Tasks.RpcTimeouts,JetBrains.Rd.Tasks.RpcTimeouts)">
            <summary>
            Choose maximal of two timeouts maximizing Warn and Error await time among two.
            </summary>
            <param name="x">First timeouts</param>
            <param name="y">Second timeouts</param>
            <returns></returns>
        </member>
        <member name="F:JetBrains.Rd.Tasks.RpcTimeouts.WarnAwaitTime">
            <summary>
            Time after which <see cref="!:ILog.Warn"/> is reported.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Tasks.RpcTimeouts.ErrorAwaitTime">
            <summary>
            Time after which <see cref="!:ILog.Error"/> is reported.
            </summary>
        </member>
        <member name="M:JetBrains.Rd.Tasks.RpcTimeouts.#ctor(System.TimeSpan,System.TimeSpan)">
            <summary>
            Creates new timeouts
            </summary>
            <param name="warnAwaitTime">Must be more than 0 ms and less or equal than <paramref name="errorAwaitTime"/>.</param>
            <param name="errorAwaitTime">Must be more or equal than <paramref name="warnAwaitTime"/></param>.
        </member>
        <member name="M:JetBrains.Rd.Text.Impl.RdTextBuffer.#ctor">
            <summary>
            Slave of the text buffer supports a list of changes that were introduced locally and can be rolled back when master buffer reports incompatible change
            </summary>
        </member>
    </members>
</doc>
